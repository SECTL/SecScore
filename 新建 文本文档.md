这是一个完整的课堂积分管理系统，使用 React + Electron + LowDB 技术栈。

让我按照你的规划，从阶段 1 开始逐步实现。

**阶段 1：初始化工程**

首先创建项目结构和基础配置：

```bash
mkdir points-manager && cd points-manager
npm init -y
```

安装依赖：

```bash
npm install electron electron-builder lowdb@5 @fluentui/react-components react react-dom react-router-dom
npm install -D typescript vite @vitejs/plugin-react concurrently wait-on @types/react @types/react-dom
```

创建核心文件：

**package.json**
```json
{
  "name": "points-manager",
  "version": "1.0.0",
  "main": "dist/main/main.js",
  "scripts": {
    "dev": "concurrently \"npm run dev:vite\" \"npm run dev:electron\"",
    "dev:vite": "vite",
    "dev:electron": "wait-on http://localhost:5173 && tsc -p tsconfig.main.json && electron .",
    "build": "tsc -p tsconfig.main.json && vite build",
    "package": "npm run build && electron-builder"
  }
}
```

**tsconfig.json**
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "dist"
  },
  "include": ["src/renderer", "src/shared"]
}
```

**tsconfig.main.json**
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "dist/main",
    "rootDir": "src/main"
  },
  "include": ["src/main", "src/shared"]
}
```

**vite.config.ts**
```ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  root: 'src/renderer',
  base: './',
  build: {
    outDir: '../../dist/renderer'
  }
});
```

**src/shared/types.ts**
```ts
export interface User {
  id: string;
  name: string;
  points: number;
}

export interface Transaction {
  id: string;
  userId: string;
  points: number;
  reason: string;
  time: string;
}

export interface Settings {
  theme: 'light' | 'dark' | 'green';
  backgroundType: 'color' | 'image';
  backgroundColor: string;
  backgroundImagePath: string;
  passwords: {
    adminEncrypted: string;
    pointsEncrypted: string;
    recoveryEncrypted: string;
  };
  backup: {
    autoBackupEnabled: boolean;
    intervalDays: number;
    maxBackups: number;
  };
}

export interface Database {
  users: User[];
  transactions: Transaction[];
  reasons: string[];
}

export type Role = 'admin' | 'points' | 'viewer';

export interface IpcResult<T = unknown> {
  ok: boolean;
  data?: T;
  error?: { code: string; message: string };
}
```

**src/shared/ipcChannels.ts**
```ts
export const IPC = {
  DB_GET_USERS: 'db:getUsers',
  DB_GET_REASONS: 'db:getReasons',
  DB_ADD_TRANSACTION: 'db:addTransaction',
  DB_GET_RANKING: 'db:getRanking',
  DB_GET_USER_TRANSACTIONS: 'db:getUserTransactions',
  DB_EXPORT_RANKING: 'db:exportRanking',
  DB_IMPORT_DATA: 'db:importData',
  DB_EXPORT_DATA: 'db:exportData',
  SETTINGS_GET: 'settings:get',
  SETTINGS_UPDATE: 'settings:update',
  AUTH_ENSURE_ROLE: 'auth:ensureRole',
  AUTH_SET_PASSWORD: 'auth:setPassword',
  AUTH_RESET_WITH_RECOVERY: 'auth:resetWithRecovery',
  BACKUP_RUN: 'backup:run',
  BACKUP_LIST: 'backup:list',
  BACKUP_RESTORE: 'backup:restore'
} as const;
```

**src/main/main.ts**
```ts
import { app, BrowserWindow, ipcMain } from 'electron';
import path from 'path';
import { registerDbHandlers } from './ipcHandlers/dbHandlers';
import { registerSettingsHandlers } from './ipcHandlers/settingsHandlers';
import { registerAuthHandlers } from './ipcHandlers/authHandlers';
import { registerBackupHandlers } from './ipcHandlers/backupHandlers';

let mainWindow: BrowserWindow | null = null;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false
    }
  });

  if (process.env.NODE_ENV === 'development') {
    mainWindow.loadURL('http://localhost:5173');
    mainWindow.webContents.openDevTools();
  } else {
    mainWindow.loadFile(path.join(__dirname, '../renderer/index.html'));
  }
}

app.whenReady().then(() => {
  registerDbHandlers();
  registerSettingsHandlers();
  registerAuthHandlers();
  registerBackupHandlers();
  createWindow();
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});
```

**src/main/preload.ts**
```ts
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electronAPI', {
  invoke: (channel: string, ...args: unknown[]) => ipcRenderer.invoke(channel, ...args)
});
```

**src/main/utils/paths.ts**
```ts
import { app } from 'electron';
import path from 'path';
import fs from 'fs';

export const getUserDataPath = () => app.getPath('userData');
export const getDbPath = () => path.join(getUserDataPath(), 'database.json');
export const getSettingsPath = () => path.join(getUserDataPath(), 'settings.json');
export const getBackupDir = () => path.join(getUserDataPath(), 'backups');

export function ensureDir(dir: string) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}
```

**src/main/services/dbService.ts**
```ts
import { Low } from 'lowdb';
import { JSONFile } from 'lowdb/node';
import { getDbPath, ensureDir, getUserDataPath } from '../utils/paths';
import type { Database, User, Transaction } from '../../shared/types';

const defaultData: Database = {
  users: [],
  transactions: [],
  reasons: ['回答问题', '作业优秀', '课堂表现', '其他']
};

let db: Low<Database>;

export async function initDb() {
  ensureDir(getUserDataPath());
  const adapter = new JSONFile<Database>(getDbPath());
  db = new Low(adapter, defaultData);
  await db.read();
  if (!db.data) db.data = defaultData;
  await db.write();
}

export async function getDb() {
  if (!db) await initDb();
  return db;
}

export async function getUsers() {
  const d = await getDb();
  return d.data.users;
}

export async function getReasons() {
  const d = await getDb();
  return d.data.reasons;
}

export async function addTransaction(t: Omit<Transaction, 'id' | 'time'>) {
  const d = await getDb();
  const transaction: Transaction = {
    ...t,
    id: `t${Date.now()}`,
    time: new Date().toISOString()
  };
  d.data.transactions.push(transaction);
  
  const user = d.data.users.find(u => u.id === t.userId);
  if (user) user.points += t.points;
  
  await d.write();
  return { transaction, newPoints: user?.points ?? 0 };
}

export async function getRanking(range: 'today' | 'week' | 'month' | 'all') {
  const d = await getDb();
  const now = new Date();
  const start = new Date();
  
  if (range === 'today') start.setHours(0, 0, 0, 0);
  else if (range === 'week') start.setDate(now.getDate() - 7);
  else if (range === 'month') start.setMonth(now.getMonth() - 1);
  else start.setTime(0);

  const rangeTransactions = d.data.transactions.filter(t => new Date(t.time) >= start);
  const changeMap = new Map<string, number>();
  rangeTransactions.forEach(t => {
    changeMap.set(t.userId, (changeMap.get(t.userId) ?? 0) + t.points);
  });

  return d.data.users
    .map(u => ({ ...u, change: changeMap.get(u.id) ?? 0 }))
    .sort((a, b) => b.points - a.points);
}

export async function getUserTransactions(userId: string) {
  const d = await getDb();
  return d.data.transactions.filter(t => t.userId === userId);
}

export async function addUser(name: string) {
  const d = await getDb();
  const user: User = { id: `u${Date.now()}`, name, points: 0 };
  d.data.users.push(user);
  await d.write();
  return user;
}

export async function importData(data: Database) {
  const d = await getDb();
  d.data = data;
  await d.write();
}

export async function exportData() {
  const d = await getDb();
  return d.data;
}
```

**src/main/services/settingsService.ts**
```ts
import fs from 'fs';
import { getSettingsPath } from '../utils/paths';
import type { Settings } from '../../shared/types';

const defaultSettings: Settings = {
  theme: 'light',
  backgroundType: 'color',
  backgroundColor: '#ffffff',
  backgroundImagePath: '',
  passwords: { adminEncrypted: '', pointsEncrypted: '', recoveryEncrypted: '' },
  backup: { autoBackupEnabled: true, intervalDays: 7, maxBackups: 10 }
};

export function getSettings(): Settings {
  const p = getSettingsPath();
  if (!fs.existsSync(p)) {
    fs.writeFileSync(p, JSON.stringify(defaultSettings, null, 2));
    return defaultSettings;
  }
  return JSON.parse(fs.readFileSync(p, 'utf-8'));
}

export function updateSettings(partial: Partial<Settings>) {
  const current = getSettings();
  const updated = { ...current, ...partial };
  fs.writeFileSync(getSettingsPath(), JSON.stringify(updated, null, 2));
  return updated;
}
```

**src/main/services/passwordService.ts**
```ts
import crypto from 'crypto';

const KEY = crypto.scryptSync('points-manager-key', 'salt', 32);
const IV = Buffer.alloc(16, 0);

export function encrypt(text: string): string {
  const cipher = crypto.createCipheriv('aes-256-cbc', KEY, IV);
  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');
}

export function decrypt(encrypted: string): string {
  const decipher = crypto.createDecipheriv('aes-256-cbc', KEY, IV);
  return decipher.update(encrypted, 'hex', 'utf8') + decipher.final('utf8');
}

export function verify(input: string, encrypted: string): boolean {
  if (!encrypted) return true;
  try {
    return decrypt(encrypted) === input;
  } catch {
    return false;
  }
}
```

**src/main/services/backupService.ts**
```ts
import fs from 'fs';
import path from 'path';
import { getBackupDir, getDbPath, ensureDir } from '../utils/paths';

export function runBackup() {
  ensureDir(getBackupDir());
  const name = `backup-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
  const dest = path.join(getBackupDir(), name);
  fs.copyFileSync(getDbPath(), dest);
  return name;
}

export function listBackups() {
  ensureDir(getBackupDir());
  return fs.readdirSync(getBackupDir()).filter(f => f.endsWith('.json')).sort().reverse();
}

export function restoreBackup(name: string) {
  const src = path.join(getBackupDir(), name);
  if (!fs.existsSync(src)) throw new Error('Backup not found');
  fs.copyFileSync(src, getDbPath());
}
```

**src/main/ipcHandlers/dbHandlers.ts**
```ts
import { ipcMain } from 'electron';
import { IPC } from '../../shared/ipcChannels';
import * as db from '../services/dbService';

export function registerDbHandlers() {
  ipcMain.handle(IPC.DB_GET_USERS, async () => ({ ok: true, data: await db.getUsers() }));
  ipcMain.handle(IPC.DB_GET_REASONS, async () => ({ ok: true, data: await db.getReasons() }));
  ipcMain.handle(IPC.DB_ADD_TRANSACTION, async (_, t) => ({ ok: true, data: await db.addTransaction(t) }));
  ipcMain.handle(IPC.DB_GET_RANKING, async (_, range) => ({ ok: true, data: await db.getRanking(range) }));
  ipcMain.handle(IPC.DB_GET_USER_TRANSACTIONS, async (_, userId) => ({ ok: true, data: await db.getUserTransactions(userId) }));
  ipcMain.handle(IPC.DB_IMPORT_DATA, async (_, data) => { await db.importData(data); return { ok: true }; });
  ipcMain.handle(IPC.DB_EXPORT_DATA, async () => ({ ok: true, data: await db.exportData() }));
}
```

**src/main/ipcHandlers/settingsHandlers.ts**
```ts
import { ipcMain } from 'electron';
import { IPC } from '../../shared/ipcChannels';
import * as settings from '../services/settingsService';

export function registerSettingsHandlers() {
  ipcMain.handle(IPC.SETTINGS_GET, () => ({ ok: true, data: settings.getSettings() }));
  ipcMain.handle(IPC.SETTINGS_UPDATE, (_, partial) => ({ ok: true, data: settings.updateSettings(partial) }));
}
```

**src/main/ipcHandlers/authHandlers.ts**
```ts
import { ipcMain } from 'electron';
import { IPC } from '../../shared/ipcChannels';
import { getSettings, updateSettings } from '../services/settingsService';
import { encrypt, verify } from '../services/passwordService';
import type { Role } from '../../shared/types';

let currentRole: Role = 'viewer';

export function registerAuthHandlers() {
  ipcMain.handle(IPC.AUTH_ENSURE_ROLE, (_, role: Role, password?: string) => {
    const s = getSettings();
    const pwKey = role === 'admin' ? 'adminEncrypted' : 'pointsEncrypted';
    
    if (!s.passwords[pwKey]) {
      currentRole = role;
      return { ok: true, data: true };
    }
    
    if (password && verify(password, s.passwords[pwKey])) {
      currentRole = role;
      return { ok: true, data: true };
    }
    
    return { ok: false, error: { code: 'AUTH_REQUIRED', message: '需要密码验证' } };
  });

  ipcMain.handle(IPC.AUTH_SET_PASSWORD, (_, { type, oldPassword, newPassword }) => {
    const s = getSettings();
    const key = type === 'admin' ? 'adminEncrypted' : 'pointsEncrypted';
    
    if (s.passwords[key] && !verify(oldPassword, s.passwords[key])) {
      return { ok: false, error: { code: 'WRONG_PASSWORD', message: '原密码错误' } };
    }
    
    updateSettings({ passwords: { ...s.passwords, [key]: encrypt(newPassword) } });
    return { ok: true };
  });

  ipcMain.handle(IPC.AUTH_RESET_WITH_RECOVERY, (_, { recovery, type, newPassword }) => {
    const s = getSettings();
    if (!verify(recovery, s.passwords.recoveryEncrypted)) {
      return { ok: false, error: { code: 'WRONG_RECOVERY', message: '找回字符串错误' } };
    }
    const key = type === 'admin' ? 'adminEncrypted' : 'pointsEncrypted';
    updateSettings({ passwords: { ...s.passwords, [key]: encrypt(newPassword) } });
    return { ok: true };
  });
}
```

**src/main/ipcHandlers/backupHandlers.ts**
```ts
import { ipcMain } from 'electron';
import { IPC } from '../../shared/ipcChannels';
import * as backup from '../services/backupService';

export function registerBackupHandlers() {
  ipcMain.handle(IPC.BACKUP_RUN, () => ({ ok: true, data: backup.runBackup() }));
  ipcMain.handle(IPC.BACKUP_LIST, () => ({ ok: true, data: backup.listBackups() }));
  ipcMain.handle(IPC.BACKUP_RESTORE, (_, name) => { backup.restoreBackup(name); return { ok: true }; });
}
```

**src/renderer/index.html**
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>积分管理系统</title>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/main.tsx"></script>
</body>
</html>
```

**src/renderer/main.tsx**
```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(<App />);
```

**src/renderer/App.tsx**
```tsx
import React, { useState, useEffect } from 'react';
import { FluentProvider, webLightTheme, webDarkTheme } from '@fluentui/react-components';
import { HashRouter, Routes, Route, NavLink } from 'react-router-dom';
import { PointsPage } from './components/points/PointsPage';
import { RankingPage } from './components/ranking/RankingPage';
import { SettingsPage } from './components/settings/SettingsPage';
import { greenTheme } from './theme/greenTheme';
import type { Settings } from '../shared/types';

const api = (window as any).electronAPI;
const themes = { light: webLightTheme, dark: webDarkTheme, green: greenTheme };

export function App() {
  const [settings, setSettings] = useState<Settings | null>(null);

  useEffect(() => {
    api.invoke('settings:get').then((r: any) => r.ok && setSettings(r.data));
  }, []);

  if (!settings) return null;

  const theme = themes[settings.theme];
  const bgStyle = settings.backgroundType === 'image'
    ? { backgroundImage: `url(${settings.backgroundImagePath})`, backgroundSize: 'cover' }
    : { backgroundColor: settings.backgroundColor };

  return (
    <FluentProvider theme={theme}>
      <HashRouter>
        <div style={{ display: 'flex', height: '100vh', ...bgStyle }}>
          <nav style={{ width: 200, padding: 16, background: 'rgba(255,255,255,0.9)' }}>
            <NavLink to="/" style={{ display: 'block', padding: 8 }}>积分管理</NavLink>
            <NavLink to="/ranking" style={{ display: 'block', padding: 8 }}>排行榜</NavLink>
            <NavLink to="/settings" style={{ display: 'block', padding: 8 }}>设置</NavLink>
          </nav>
          <main style={{ flex: 1, padding: 24, overflow: 'auto' }}>
            <Routes>
              <Route path="/" element={<PointsPage />} />
              <Route path="/ranking" element={<RankingPage />} />
              <Route path="/settings" element={<SettingsPage onUpdate={setSettings} />} />
            </Routes>
          </main>
        </div>
      </HashRouter>
    </FluentProvider>
  );
}
```

**src/renderer/theme/greenTheme.ts**
```ts
import { createLightTheme, BrandVariants } from '@fluentui/react-components';

const green: BrandVariants = {
  10: '#020402', 20: '#0d1f12', 30: '#14331c', 40: '#194324',
  50: '#1e542c', 60: '#236534', 70: '#28773d', 80: '#2d8945',
  90: '#329c4e', 100: '#37ae57', 110: '#4fba6a', 120: '#68c67e',
  130: '#82d292', 140: '#9cdea7', 150: '#b6eabc', 160: '#d1f6d2'
};

export const greenTheme = createLightTheme(green);
```

**src/renderer/components/points/PointsPage.tsx**
```tsx
import React, { useState, useEffect } from 'react';
import { Dropdown, Input, Button, RadioGroup, Radio, Option } from '@fluentui/react-components';
import type { User } from '../../../shared/types';

const api = (window as any).electronAPI;

export function PointsPage() {
  const [users, setUsers] = useState<User[]>([]);
  const [reasons, setReasons] = useState<string[]>([]);
  const [userId, setUserId] = useState('');
  const [points, setPoints] = useState('10');
  const [type, setType] = useState<'add' | 'sub'>('add');
  const [reason, setReason] = useState('');

  useEffect(() => {
    api.invoke('db:getUsers').then((r: any) => r.ok && setUsers(r.data));
    api.invoke('db:getReasons').then((r: any) => r.ok && setReasons(r.data));
  }, []);

  const submit = async () => {
    if (!userId || !points || !reason) return alert('请填写完整');
    const p = type === 'add' ? +points : -points;
    const r = await api.invoke('db:addTransaction', { userId, points: p, reason });
    if (r.ok) {
      alert(`操作成功，当前积分：${r.data.newPoints}`);
      setPoints('10');
    }
  };

  return (
    <div style={{ maxWidth: 400 }}>
      <h2>积分管理</h2>
      <div style={{ marginBottom: 16 }}>
        <label>学生</label>
        <Dropdown placeholder="选择学生" onOptionSelect={(_, d) => setUserId(d.optionValue!)}>
          {users.map(u => <Option key={u.id} value={u.id}>{u.name}</Option>)}
        </Dropdown>
      </div>
      <div style={{ marginBottom: 16 }}>
        <RadioGroup value={type} onChange={(_, d) => setType(d.value as 'add' | 'sub')}>
          <Radio value="add" label="加分" />
          <Radio value="sub" label="扣分" />
        </RadioGroup>
      </div>
      <div style={{ marginBottom: 16 }}>
        <label>分值</label>
        <Input type="number" value={points} onChange={(_, d) => setPoints(d.value)} />
      </div>
      <div style={{ marginBottom: 16 }}>
        <label>理由</label>
        <Dropdown placeholder="选择理由" onOptionSelect={(_, d) => setReason(d.optionValue!)}>
          {reasons.map(r => <Option key={r} value={r}>{r}</Option>)}
        </Dropdown>
      </div>
      <Button appearance="primary" onClick={submit}>提交</Button>
    </div>
  );
}
```

**src/renderer/components/ranking/RankingPage.tsx**
```tsx
import React, { useState, useEffect } from 'react';
import { Dropdown, Option, Table, TableHeader, TableRow, TableHeaderCell, TableBody, TableCell } from '@fluentui/react-components';

const api = (window as any).electronAPI;

export function RankingPage() {
  const [range, setRange] = useState<'today' | 'week' | 'month' | 'all'>('all');
  const [data, setData] = useState<any[]>([]);

  useEffect(() => {
    api.invoke('db:getRanking', range).then((r: any) => r.ok && setData(r.data));
  }, [range]);

  return (
    <div>
      <h2>排行榜</h2>
      <Dropdown value={range} onOptionSelect={(_, d) => setRange(d.optionValue as any)}>
        <Option value="today">今天</Option>
        <Option value="week">本周</Option>
        <Option value="month">本月</Option>
        <Option value="all">全部</Option>
      </Dropdown>
      <Table style={{ marginTop: 16 }}>
        <TableHeader>
          <TableRow>
            <TableHeaderCell>排名</TableHeaderCell>
            <TableHeaderCell>姓名</TableHeaderCell>
            <TableHeaderCell>总积分</TableHeaderCell>
            <TableHeaderCell>变化</TableHeaderCell>
          </TableRow>
        </TableHeader>
        <TableBody>
          {data.map((u, i) => (
            <TableRow key={u.id}>
              <TableCell>{i + 1}</TableCell>
              <TableCell>{u.name}</TableCell>
              <TableCell>{u.points}</TableCell>
              <TableCell style={{ color: u.change >= 0 ? 'green' : 'red' }}>
                {u.change >= 0 ? '+' : ''}{u.change}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
```

**src/renderer/components/settings/SettingsPage.tsx**
```tsx
import React, { useState } from 'react';
import { TabList, Tab, RadioGroup, Radio, Input, Button } from '@fluentui/react-components';
import type { Settings } from '../../../shared/types';

const api = (window as any).electronAPI;

export function SettingsPage({ onUpdate }: { onUpdate: (s: Settings) => void }) {
  const [tab, setTab] = useState('appearance');

  const updateTheme = async (theme: string) => {
    const r = await api.invoke('settings:update', { theme });
    if (r.ok) onUpdate(r.data);
  };

  return (
    <div>
      <h2>设置</h2>
      <TabList selectedValue={tab} onTabSelect={(_, d) => setTab(d.value as string)}>
        <Tab value="appearance">外观</Tab>
        <Tab value="security">安全</Tab>
        <Tab value="data">数据</Tab>
        <Tab value="about">关于</Tab>
      </TabList>
      <div style={{ marginTop: 16 }}>
        {tab === 'appearance' && (
          <RadioGroup onChange={(_, d) => updateTheme(d.value)}>
            <Radio value="light" label="浅色" />
            <Radio value="dark" label="深色" />
            <Radio value="green" label="护眼绿" />
          </RadioGroup>
        )}
        {tab === 'security' && <SecurityTab />}
        {tab === 'data' && <DataTab />}
        {tab === 'about' && <div>积分管理系统 v1.0.0</div>}
      </div>
    </div>
  );
}

function SecurityTab() {
  const [oldPw, setOldPw] = useState('');
  const [newPw, setNewPw] = useState('');

  const setPassword = async (type: 'admin' | 'points') => {
    const r = await api.invoke('auth:setPassword', { type, oldPassword: oldPw, newPassword: newPw });
    alert(r.ok ? '设置成功' : r.error.message);
  };

  return (
    <div>
      <Input placeholder="原密码" type="password" value={oldPw} onChange={(_, d) => setOldPw(d.value)} />
      <Input placeholder="新密码(6位数字)" type="password" value={newPw} onChange={(_, d) => setNewPw(d.value)} />
      <Button onClick={() => setPassword('admin')}>设置管理密码</Button>
      <Button onClick={() => setPassword('points')}>设置积分密码</Button>
    </div>
  );
}

function DataTab() {
  const backup = () => api.invoke('backup:run').then((r: any) => alert(r.ok ? '备份成功' : '失败'));
  const exportData = async () => {
    const r = await api.invoke('db:exportData');
    if (r.ok) {
      const blob = new Blob([JSON.stringify(r.data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'data.json';
      a.click();
    }
  };

  return (
    <div>
      <Button onClick={backup}>手动备份</Button>
      <Button onClick={exportData}>导出数据</Button>
    </div>
  );
}
```
